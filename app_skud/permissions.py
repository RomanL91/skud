# не используется!


from rest_framework import permissions
from django.contrib.auth.models import Group


# довольно сложная логика, подробно опишу
# ====================================================================================
# '''
# здесь получаю все группы которые есть в системе
# пример выглядит так:
#      {'HR': ['accessprofile', 'monitorcheckaccess'], 'Security': [], 'Admins': []}
# формируется словарь, где ключ - это имя группы,
# значение - список в котором сохранены view к которым хотим ограничить доступ
# даже просто для просмотра. Как видно из примера у HR ограничен доступ к энтрипоинтам
# по которым они могут получать весь список записи.
# '''
data = {str(el): [] for el in Group.objects.all()}
# ====================================================================================
# '''
# тут буквально прописывается, что этой группе нельзя обращаться к этим
# конечным точкам. И пример как это прописывается, считай настройка
# на уровне кода приложения. Тонкое место.
# Конечно, не очевидно откуда известны имена view, это следует знать,
# что имена view это имена моделей (models.py) в нижнем регистре.
# '''
data["HR"] = ["accessprofile", "monitorcheckaccess"]


# ====================================================================================
# '''
# далее создание кастомного класс ограничения, который мы по сути
# нигде использовать не будем, другими словами, мы не будем его импортировать
# куда либо и уж тем более привязывть к какому либо View. Он нужен нам
# только для того, что переопределить логику метода:
# has_permission
# что это за метод посмотри тут: permissions_execution.png(лежит в корне проекта),
# и интернет ресурс: https://testdriven.io/blog/drf-permissions/
# так же документация DRF.
# В этих источниках можно понять что это за метод и что он делает,
# но чтобы его переопределить создается ценый класс.
# '''
class UsersWithGroups(permissions.BasePermission):
    def has_permission(self, request, view):
        user_groups = request.user.groups.all()  # получаю все группы пользователя
        list_user_groups = [
            str(el) for el in user_groups
        ]  # формирую удобный формат из полученный груп: ['HR', 'Security', 'Admins']
        try:
            name_view = view.basename  # пробую получить имя view
        except:
            name_view = None  # не получил - значит None

        if request.user.is_superuser:  # если запрос сделал суперпользователь
            return True  # вернуть истину
        else:  # иначе
            if (
                request.user.is_authenticated
            ):  # если запрос от аутенфицированного пользователя
                for group in list_user_groups:  # перебираем группы пользователя
                    if group in list(
                        data.keys()
                    ):  # если группа пользователя есть в data(определенна вначале)
                        private_views_for_group = data[
                            group
                        ]  # получаем список view к которвм ограничен доступ
                        if (
                            name_view in private_views_for_group
                        ):  # если имя view которое вызывается сейчас есть в списке
                            return False  # вернуть ложь
                    return True  # вернется если у пользователя даже нет группы (это админы)
            return False  # вернется если пользователь не залогинился
